import { withRouter } from 'next/router'
import WithMDX from '../../../lib/with-mdx'

import { nelson } from '../../../lib/data/team'
import Tangle from '../../../components/tangle'

export const page = {
title: 'Deep Dive - Addresses',
date: '4 Sep 2018',
authors: [nelson],
editUrl: 'pages/hub/deep-dive-addresses.mdx',
}

export default withRouter(props => WithMDX(props, page))


If you want to understand how addresses are generated, keep reading.  Otherwise, skip to the next section.  
 
Addresses are generated from seeds.  The algorithm used to generate addresses is not random. First, the algorithm deterministically creates a series of addresses by adding the index of the address as if it were a number stored with least significant bytes first.
 
Next, a sub-seed, private key, and address are generated from the original seed+index as follows:
 
1. The seed+index is hashed into a sub-seed.  Due to the nature of hashing, reverse engineering back to the original seed is next to impossible using current technology
 
2. The sub-seed is hashed into a private key.  The length of the private key depends on the security level selected.  You have the option to choose between three security levels:

	Security Level 1: 81-trit security (low)

	Security Level 2: 162-trit security (medium)

	Security Level 3: 243-trit security (high)

 
3. We advise exchanges to use Level 3 security (243-trit) for all addresses which are generated for hot wallet, cold storage and multi-signature addresses. For efficiency reasons, security Level 2 is sufficient for user deposits.
 
4. Private keys can be easily re-generated from the seed+index, so there is no need to store them.
 
5. Next, the private key is hashed into 27 key fragments that are each hashed 26 times.  These key fragments play an essential role in the Winternitz signing process when funds from an address are spent.
 
6. Finally, the hashed key fragments are hashed together into a public key.  This public key is the address.[1]

 
In addition to security, when it comes to addresses that are being used for back-end (internal shuffling around of balances) and front-end (user deposits), we advise exchanges to always generate and enforce address checksums. This is especially important for user-related functions (e.g. processing withdrawal), as users sometimes make the mistake of handing out the wrong address. Check the respective utility functions addChecksum(), isAddress() and isValidChecksum() 

When generating a new address for sending a transaction via the API, remember you may need to add the checksum which extends the address length to 90 trytes.


**References:**

[1] *How IOTA Addresses are Generated from Seeds*, by Eric Hop.  Published at https://medium.com/iota-demystified/how-iota-addresses-are-generated-from-seeds-40f554e38818